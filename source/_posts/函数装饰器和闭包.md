---
title: 函数装饰器和闭包
date: 2020-06-01 22:27:58
tags: python
---

装饰器的一大特性是,能把被装饰的函数替换成其他函数。第二个特性是,装饰器在加载模块时立即执行。

<!--more-->

下面是第一个特性：
```python
def deco(func):
	def inner():
		print('running inner()')
	return inner

@deco
def target():
	print('running target()')

>>> target()
running inner()
>>> target
<function deco.<locals>.inner at 0x10063b598>
```
被装饰的target现在是inner的引用。

```python
registry = []
def register(func):
	print('running register(%s)' % func)
	registry.append(func)
	return func

@register
def f1():
	print('runningf1()')

@register
def f2():
	print('runningf2()')

def f3():
	print('running f3()')

def main():
	print('running main()')
	print('registry ->', registry)
	f1()
	f2()
	f3()

if__name__=='__main__':
main()
```
运行：
```python
python3 registration.py
running register(<function f1 at 0x100631bf8>)
running register(<function f2 at 0x100631c80>)
running main()
registry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>]
running f1()
running f2()
running f3()
```
如果直接导入：
```python
>>> import registration
running register(<function f1 at 0x10063b1e0>)
running register(<function f2 at 0x10063b268>)
>>> registration.registry
[<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]
```
函数装饰器在导入模块时立即执行,而被装饰的函数只在明确调用时运行。这突出了 Python 程序员所说的导入时和运行时之间的区别。

#### 使用装饰器改进“策略”模式
之前的模式的主要问题是,定义体中有函数的名称,但是best_promo 用来判断哪个折扣幅度最大的 promos 列表中也有函数名称。这种重复是个问题,因为新增策略函数后可能会忘记把它添加到promos 列表中,导致 best_promo 忽略新策略,而且不报错,为系统引入了不易察觉的缺陷。
下面是用装饰器实现：
```python
promos = []

def promotion(promo_func):  # promotion 把 promo_func 添加到 promos 列表中,然后原封不动地将其返回。
    promos.append(promo_func)
    return promo_func


@promotion           # 被 @promotion 装饰的函数都会添加到 promos 列表中。
def fidelity(order):
    """为积分为1000或以上的顾客提供5%折扣"""
    return order.total() * .05 if order.customer.fidelity >= 1000 else 0


@promotion
def bulk_item(order):
    """单个商品为20个或以上时提供10%折扣"""
    discount = 0
    for item in order.cart:
        if item.quantity >= 20:
            discount += item.total() * .1
    return discount

@promotion
def large_order(order):
    """订单中的不同商品达到10个或以上时提供7%折扣"""
    distinct_items = {item.product for item in order.cart}
    if len(distinct_items) >= 10:
        return order.total() * .07
    return 0

def best_promo(order):
    return max(promo(order) for promo in promos)
```
这个方案有几个优点。
- 促销策略函数无需使用特殊的名称(即不用以 _promo 结尾)。
- @promotion 装饰器突出了被装饰的函数的作用,还便于临时禁用某个促销策略:只需把装饰器注释掉。
- 促销折扣策略可以在其他模块中定义,在系统中的任何地方都行,只要使用 @promotion 装饰即可。


### 变量作用域规则
```python
>>> b = 6
>>> def f2(a):
... print(a)
... print(b)
... b = 9
...
>>> f2(3)
3
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "<stdin>", line 3, in f2
UnboundLocalError: local variable 'b' referenced before assignment
```
事实是,Python 编译函数的定义体时,它判断 b 是局部变量,因为在函数中给它赋值了。生成的字节码证实了这种判断,Python 会尝试从本地环境获取 b。后面调用 f2(3) 时, f2 的定义体会获取并打印局部变量 a 的值,但是尝试获取局部变量 b 的值时,发现 b 没有绑定值。

> Python不要求声明变量,但是假定在函数定义体中赋值的变量是局部变量。

如果在函数中赋值时想让解释器把 b 当成全局变量,要使用 global 声明:
```python
In [8]: b = 6
In [9]: def f3(a):
   ...:     global b
   ...:     print(a)
   ...:     print(b)
   ...:     b = 9
In [10]: f3(3)
3
6
In [11]: b
Out[11]: 9

In [12]: f3(3)
3
9
```